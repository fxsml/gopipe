package gopipe

import (
	"context"
	"fmt"
	"sync"
)

var ErrExpand = fmt.Errorf("gopipe: expand")

// ExpandHandler is a function that processes an input value and returns multiple output values.
// It takes a context and an input value, and returns a slice of output values and an error.
// If the error is non-nil, the output values will be ignored.
type ExpandHandler[In, Out any] func(context.Context, In) ([]Out, error)

// Expand transforms each input value into zero or more output values using the provided handler function.
// Unlike Process, which produces exactly one output per input, Expand can generate multiple outputs or
// even no output at all for each input value.
//
// Expand is useful for operations that naturally produce a variable number of results, such as:
//   - Splitting a collection into individual items
//   - Generating permutations or combinations
//   - Filtering with expansion (e.g., retrieving related items from a database)
//   - Unpacking nested data structures
//
// The function supports concurrent processing through the WithConcurrency option, allowing
// multiple items to be expanded in parallel. The WithBuffer option controls the buffer
// size of the output channel.
//
// If the handler returns an error for an input, that error is passed to the error handler
// and no output values are produced for that input.
//
// The goroutine(s) started by Expand will exit automatically when either:
//   - The input channel is closed
//   - The provided context is cancelled
//
// The output channel will be closed when all processing completes.
//
// Example:
//
//	// Split sentences into words
//	sentences := make(chan string)
//	words := gopipe.Expand(ctx, sentences, func(ctx context.Context, sentence string) ([]string, error) {
//	    // Split the sentence into words
//	    return strings.Fields(sentence), nil
//	}, gopipe.WithConcurrency(3))
//
//	// Now 'words' will receive individual words from all sentences
//
// Returns a channel that will receive all output values generated by the handler function.
func Expand[In, Out any](
	ctx context.Context,
	in <-chan In,
	handler ExpandHandler[In, Out],
	opts ...Option,
) <-chan Out {
	cfg := defaultConfig
	for _, opt := range opts {
		opt(&cfg)
	}

	out := make(chan Out, cfg.buffer)

	var wg sync.WaitGroup
	wg.Add(cfg.concurrency)
	for range cfg.concurrency {
		go func() {
			defer wg.Done()
			for {
				select {
				case <-ctx.Done():
					return
				case val, ok := <-in:
					if !ok {
						return
					}
					ctxExpand, cancel := cfg.ctx(ctx)
					if res, err := handler(ctxExpand, val); err != nil {
						cfg.err(val, fmt.Errorf("%w: %w", ErrExpand, err))
					} else {
						for _, res := range res {
							select {
							case <-ctx.Done():
								return
							case out <- res:
							}
						}
					}
					cancel()
				}
			}
		}()
	}

	go func() {
		wg.Wait()
		close(out)
	}()

	return out
}
